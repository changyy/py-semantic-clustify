#!/usr/bin/env python3
"""
Development helper script for semantic-clustify project.

This script provides common development tasks in a Python-native way.
Usage: python tools/dev_helper.py [command]

Available commands:
- test: Run pytest with coverage
- lint: Run code quality checks
- format: Format code with black
- build: Build the package
- clean: Clean build artifacts
- install: Install package in development mode
- check: Run all quality checks
"""

import sys
import subprocess
import argparse
from pathlib import Path
import shutil


def ensure_project_root():
    """Ensure we're running from the project root directory."""
    current_dir = Path.cwd()

    # Check if we're in the tools directory
    if current_dir.name == "tools":
        import os

        os.chdir(current_dir.parent)
        print(f"Changed directory to project root: {Path.cwd()}")


def run_command(cmd, description="", exit_on_error=True):
    """Run a command and return success status."""
    if description:
        print(f"üîß {description}")

    if isinstance(cmd, str):
        cmd = cmd.split()

    print(f"Running: {' '.join(cmd)}")
    result = subprocess.run(cmd)

    if exit_on_error and result.returncode != 0:
        print(f"‚ùå Command failed with exit code {result.returncode}")
        sys.exit(result.returncode)

    return result.returncode == 0


def cmd_clean():
    """Clean build artifacts, cache files, and temporary test outputs."""
    print("üßπ Cleaning build artifacts and temporary files...")

    patterns_to_remove = [
        "build",
        "dist",
        "*.egg-info",
        "__pycache__",
        ".pytest_cache",
        ".coverage",
        "htmlcov",
        # Temporary CLI output files (generated by tests)
        "*_kmeans_grouped_*.jsonl",
        "*_dbscan_grouped_*.jsonl",
        "*_hierarchical_grouped_*.jsonl",
        "*_gmm_grouped_*.jsonl",
        "*_kmeans_labeled_*.jsonl",
        "*_dbscan_labeled_*.jsonl",
        "*_hierarchical_labeled_*.jsonl",
        "*_gmm_labeled_*.jsonl",
        "tmp*_*.jsonl",  # Temporary files from tests
        "test_input_*.jsonl",  # Test input files
        "clustered_output_*.jsonl",  # Default output files
    ]

    for pattern in patterns_to_remove:
        if pattern.startswith("*"):
            # Handle glob patterns
            from glob import glob

            for path in glob(pattern):
                if Path(path).exists():
                    if Path(path).is_dir():
                        shutil.rmtree(path)
                        print(f"Removed directory: {path}")
                    else:
                        Path(path).unlink()
                        print(f"Removed file: {path}")
        else:
            path = Path(pattern)
            if path.exists():
                if path.is_dir():
                    shutil.rmtree(path)
                    print(f"Removed directory: {path}")
                else:
                    path.unlink()
                    print(f"Removed file: {path}")

    # Find and remove all __pycache__ directories
    for pycache in Path(".").rglob("__pycache__"):
        if pycache.is_dir():
            shutil.rmtree(pycache)
            print(f"Removed: {pycache}")

    print("‚úÖ Clean completed!")


def cmd_test():
    """Run tests with coverage."""
    run_command(
        [
            "python",
            "-m",
            "pytest",
            "tests/",
            "-v",
            "--cov=semantic_clustify",
            "--cov-report=term-missing",
            "--cov-report=html",
        ],
        "Running tests with coverage",
    )


def cmd_lint():
    """Run linting checks."""
    print("üîç Running code quality checks...")

    # Flake8 for syntax errors
    run_command(
        [
            "python",
            "-m",
            "flake8",
            "semantic_clustify/",
            "--count",
            "--select=E9,F63,F7,F82",
            "--show-source",
            "--statistics",
        ],
        "Checking for syntax errors",
        exit_on_error=False,
    )

    # Flake8 for style
    run_command(
        [
            "python",
            "-m",
            "flake8",
            "semantic_clustify/",
            "--count",
            "--exit-zero",
            "--max-complexity=10",
            "--max-line-length=88",
            "--statistics",
        ],
        "Checking code style",
        exit_on_error=False,
    )


def cmd_format():
    """Format code with black."""
    run_command(
        ["python", "-m", "black", "semantic_clustify/", "tests/", "tools/"],
        "Formatting code with black",
    )


def cmd_build():
    """Build the package."""
    run_command(["python", "-m", "build"], "Building package")


def cmd_install():
    """Install package in development mode."""
    run_command(
        ["python", "-m", "pip", "install", "-e", ".[dev]"],
        "Installing package in development mode",
    )


def cmd_check():
    """Run all quality checks."""
    print("üöÄ Running all quality checks...")
    cmd_format()
    cmd_lint()
    cmd_test()
    print("‚úÖ All checks completed!")


def cmd_version():
    """Show current version."""
    try:
        import semantic_clustify

        print(f"Current version: {semantic_clustify.__version__}")
    except ImportError:
        print("Package not installed. Run 'python tools/dev_helper.py install' first.")


def main():
    """Main entry point."""
    ensure_project_root()

    parser = argparse.ArgumentParser(
        description="Development helper for semantic-clustify",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )

    parser.add_argument(
        "command",
        choices=[
            "test",
            "lint",
            "format",
            "build",
            "clean",
            "install",
            "check",
            "version",
        ],
        help="Command to run",
    )

    args = parser.parse_args()

    commands = {
        "test": cmd_test,
        "lint": cmd_lint,
        "format": cmd_format,
        "build": cmd_build,
        "clean": cmd_clean,
        "install": cmd_install,
        "check": cmd_check,
        "version": cmd_version,
    }

    try:
        commands[args.command]()
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è  Operation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
